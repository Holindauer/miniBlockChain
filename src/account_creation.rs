use tokio::io::AsyncWriteExt;
use tokio::net::TcpStream;
use serde::{Serialize, Deserialize};
use serde_json;
use std::io;

extern crate secp256k1;
extern crate rand;

use secp256k1::{Secp256k1, SecretKey, PublicKey};
use rand::{thread_rng, RngCore}; // Ensure thread_rng is imported here

/**
 * @notice account_creation.rs contains the logic for sending a request to the network to create a new account.
 * This is done by generating a new keypair using the secp256k1 elliptic curve, then sending the public key to
 * the network. Validtors will receive this message and update their merkle tree to include the new account.
 * 
 * The account_creation() function is called from main.rs when the user runs the node software with the [make]
*/

const PORT_NUMBER: &str = "127.0.0.1:8080"; // TODO figure out how to link thi between src files

/**
 * @notice KeyPair encapsulate a new private and public key generated for a new 
 * blockchain account for the purpose of sending to other nodes in the network.
 */
#[derive(Serialize, Deserialize)]
pub struct AccountCreationRequest {
    pub action: String,
    pub public_key: String,
}

/**
 * @notice account_creation() is a wrapper called within main.rs that instigates the process of accessing 
 * the network from the client side, creating a new account, and saving the account details within ledger
 */
pub fn account_creation() {

    // Create a new Tokio runtime 
    let rt = tokio::runtime::Runtime::new().unwrap();

    // block_on the account creation process, display the results   
    match rt.block_on(send_account_creation_request()) { 
        Ok(keys) => {
            println!("Account detials sucessfully created: \n\nSecret Key: {:?}, \nPublic Key: {:?}", keys.0.to_string(), keys.1.to_string());
        },
        Err(e) => { eprintln!("Account creation failed: {}", e); return; },
    };
}

/**
 * @notice send_account_creation_msg() asynchonously creates and packages a new keypair. Then sends
 * uses tohe send_network_msg() func to distribute it to other nodes in the network.
 * @return a tuple of the secret and public key generated for the new account.
 */
async fn send_account_creation_request() -> Result<(SecretKey, PublicKey), io::Error> {
    println!("\nSending account creation message to network...");

    // Generate a new keypair
    let (secret_key, public_key) = generate_keypair()?;

    // package account creation request
    let request: AccountCreationRequest = AccountCreationRequest {
        action: "make".to_string(),
        public_key: public_key.to_string(),
    };

    // Connect to the server at the specified port number
    let mut stream: TcpStream = TcpStream::connect(PORT_NUMBER).await?;

    // Serialize request to JSON, write to stream
    let request_json: String = serde_json::to_string(&request)?;
    stream.write_all(request_json.as_bytes()).await?;

    // Return the generated secret key and public key
    Ok((secret_key, public_key))
}


/**
 * @notice generate_keypair() applies the sepc256k1 eliptic curve to generate a new private 
 * and public keypair. This function is used in the account creation process. 
 * @dev sepc256k1 is an elliptic curve used in Bitcoin and Ethereum (y^2 = x^3 + 7). This curve  
 * is used to perform elliptic curve point addition over a finite field w/ the generator term. 
 * @dev In this function, a key pair is generated by creating a random 256 bit number in the \
 * range of 0 to the field modulus, then mult
 */
fn generate_keypair() -> Result<(SecretKey, PublicKey), io::Error> {

    // Create a new secp256k1 context
    let secp = Secp256k1::new();

    // Generate a new cryptographically random number generator  
    let mut rng = thread_rng();

    // Generate a new secret key
    let mut secret_key_bytes = [0u8; 32]; // arr of 32 bytes
    rng.fill_bytes(&mut secret_key_bytes);    // fill w/ random bytes
    
    // encapsulate the secret key bytes into a SecretKey type for safer handling
    let secret_key: SecretKey = SecretKey::from_slice(&secret_key_bytes)
        .map_err(|e| io::Error::new(io::ErrorKind::Other, e.to_string()))?; // map error to io::Error from secp256k1::Error

    // Derive the public key from the secret key
    let public_key: PublicKey = PublicKey::from_secret_key(&secp, &secret_key);

    Ok((secret_key, public_key))
}


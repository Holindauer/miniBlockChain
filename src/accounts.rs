use tokio::io::AsyncWriteExt;
use tokio::net::TcpStream;
use serde::{Serialize, Deserialize};
use serde_json;
use std::io;

extern crate secp256k1;
extern crate rand;

use secp256k1::{Secp256k1, SecretKey, PublicKey};
use rand::{thread_rng, RngCore}; // Ensure thread_rng is imported here

const PORT_NUMBER: &str = "127.0.0.1:8080";

/**
 * @notice KeyPair encapsulate a new private and public key generated for a new 
 * blockchain account for the purpose of sending to other nodes in the network.
 */
#[derive(Serialize, Deserialize)]
pub struct AccountCreationRequest {
    pub action: String,
    pub public_key: String,
    // TODO - other data
}

/**
 * @notice account_creation() is a wrapper called within main.rs that instigates the process of accessing 
 * the network from the client side, creating a new account, and saving the account details within ledger
 */
pub fn account_creation() {

    // Create a new Tokio runtime 
    let rt = tokio::runtime::Runtime::new().unwrap();

    // Use the runtime to block_on  the account creation process (run an async process in a synchronous 
    // context). Output from send_account creation_msg() is a future that will resolve to a Result type.   
    match rt.block_on(send_account_creation_msg()) { 

        Ok(_) => println!("Account creation process initiated successfully."),
        Err(e) => eprintln!("Account creation failed: {}", e),
    }
}

/**
 * @notice send_account_creation_msg() asynchonously creates and packages a new keypair. Then sends
 * uses tohe send_network_msg() func to distribute it to other nodes in the network.
 */
async fn send_account_creation_msg() -> tokio::io::Result<()> {

    // Generate a new keypair
    let (secret_key, public_key) = generate_keypair()?;

    // example msg of account creation
    let message: AccountCreationRequest = AccountCreationRequest {
        action: "make".to_string(),
        public_key: public_key.to_string(),
    };

    // Sending the message to a specific address or broadcast it
    send_network_msg("127.0.0.1:8080", message).await
}


/**
 * @notice send_network_msg() asynchronously sends the generated 
 */
async fn send_network_msg(addr: &str, message: AccountCreationRequest) -> tokio::io::Result<()> {

    // Connect to the server
    let mut stream: TcpStream = TcpStream::connect(addr).await?;

    // Serialize the message to JSON
    let message_json: String = serde_json::to_string(&message)?;

    // Write the message to the server
    stream.write_all(message_json.as_bytes()).await?;

    Ok(())
}

/**
 * @notice generate_keypair() applies the sepc256k1 eliptic curve to generate a new private 
 * and public keypair. This function is used in the account creation process. 
 * @dev sepc256k1 is an elliptic curve used in Bitcoin and Ethereum (y^2 = x^3 + 7). This curve  
 * is used to perform elliptic curve point addition over a finite field w/ the generator term. 
 * @dev In this function, a key pair is generated by creating a random 256 bit number in the \
 * range of 0 to the field modulus, then mult
 */
fn generate_keypair() -> Result<(SecretKey, PublicKey), io::Error> {

    // Create a new secp256k1 context
    let secp = Secp256k1::new();

    // Generate a new cryptographically random number generator  
    let mut rng = thread_rng();

    // Generate a new secret key
    let mut secret_key_bytes = [0u8; 32]; // arr of 32 bytes
    rng.fill_bytes(&mut secret_key_bytes);    // fill w/ random bytes
    
    // encapsulate the secret key bytes into a SecretKey type for safer handling
    let secret_key: SecretKey = SecretKey::from_slice(&secret_key_bytes)
        .map_err(|e| io::Error::new(io::ErrorKind::Other, e.to_string()))?; // map error to io::Error from secp256k1::Error

    // Derive the public key from the secret key
    let public_key: PublicKey = PublicKey::from_secret_key(&secp, &secret_key);

    Ok((secret_key, public_key))
}

